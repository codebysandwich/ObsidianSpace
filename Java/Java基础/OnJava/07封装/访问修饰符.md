Java中一共4总访问修饰符，`public`、 `protected`、`default`、`private`。对应的访问权限如下，所有的访问权限都是对类（仅private权限）或对象而言的：

|  修饰符   | 当前类 | 同包 | 子类 | 其他包 |
|:---------:|:------:|:----:|:----:|:------:|
|  private  |   ✅   |  ❌  |  ❌  |   ❌   |
|  default  |   ✅   |  ✅  |  ❌  |   ❌   |
| protected |   ✅   |  ✅  |  ✅  |   ❌   |
|  public   |   ✅   |  ✅  |  ✅  |   ✅   |

> 其中子类指的是外部包中的子类

- private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）
- default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。
- protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。
- public : 对所有类可见。使用对象：类、接口、变量、方法

> private、protected 不能修饰外部类或顶级类，只能用以修饰内部类


# private 你无法访问

关键字 **private** 意味着除了包含该成员的类，其他任何类都无法访问这个成员。使用 **private** ，你可以自由地修改那个被修饰的成员，无需担心会影响同一包下的其他类。

```java
class Sundae {
    private Sundae() {}

    static Sundae makeSundae() {
        return new Sundae();
    }
}

public class IceCream {
    public static void main(String[] args) {
        // Sundae sundae = new Sundae(); - 受保护的构造函数
        Sundae sundae = Sundae.makeSundae();
    }
}
```

Sundae构造函数是私有的，只有Sundae类内部可以使用。所以必须使用`makeSundae()`来初始化对象并获得对象实例。

# protected: 继承访问权限
关键字 **protected** 处理的是继承的概念，在`包访问`的基础上，包外访问限制在子类可以，保护了继承关系。

示例，com/onjava/hiding/cookie2包下定义`Cookie`基类，定义protected访问权限的`bite()`方法

```java
package com.onjava.hiding.cookie2;

public class Cookie {
    public Cookie() {
        System.out.println("Cookie constructor");
    }

    protected void bite() {
        System.out.println("bite");
    }
}
```

com/onjava/hiding(基类包外)的ChocolateChip2类继承Cookie(cookie2的)，由于protected的访问权限，可以在包外继承父类的`bite()`方法

```java
package com.onjava.hiding;

import com.onjava.hiding.cookie2.Cookie;

public class ChocolateChip2 extends Cookie{
    public ChocolateChip2() {
        System.out.println("ChocolateChip constructor");
    }

    public void chomp() {
        bite();
    }

    public static void main(String[] args) {
        ChocolateChip2 x = new ChocolateChip2();
        x.chomp();
    }
}
```

如果父类的`bite()`方法是default(包访问权限)，则包外的子类无法继承(调用)该方法!

# 包访问权限 VS public构造器

如果一个类(hiding.packageaccess.PublicConstructor)是包访问权限的，但是其构造器是public访问权限的，包外(hiding)同样也是无法使用new来创建对应示例的：

```java
package com.onjava.hiding.packageaccess;

class PublicConstructor {
    public PublicConstructor() {}
}
```

```java
package com.onjava.hiding;

import com.onjava.hiding.packageaccess.*;

public class CreatePackageAccessObject {
    public static void main(String[] args) {
        // new PublicConstructor();
        /*
         'com.onjava.hiding.packageaccess.PublicConstructor' is not public in 'com.onjava.hiding.packageaccess'. 
         Cannot be accessed from outside package 
        */
    }
}
```

可见，在一个具有包访问权限的类中定义一个 **public** 的构造器并不能真的使这个构造器成为 **public** ，在声明的时候就应该标记为编译时错误。



